## 1-express前+后(服务器)+库

### mongodb库、Navicat图形化、mongoose

```js
//库下载网址   https://www.mongodb.com/try/download/enterprise
//install MongoDB compass  不勾选
//安装mongoose
npm i mongoose
```

### 数据库链接--实例

```js
// a.js
let mongoose=require('mongoose');
let dbURL='mongodb://127.0.0.1:27017/数据库名称';
mongoose.connect(dbURL, {
    //固定配置
    useNewUrlParser:true,
    useUnifiedTopology:true
});
//设置连接成功时要执行的回调函数
mongoose.connection.on('connected',function(){
    console.log('数据库连接成功!');
});

/*在app.js 
require('./a.js');*/
```

### 数据库集合--实例

```js
let mongoose=require('mongoose');
let userSchema=new mongoose.Schema({
    account:String,
    password:String
});
let userModel=mongoose.model('userModel',userSchema,'user');

/*
引入`mongoose`模块（模块对象）
let 模型名称=new mongoose.Schema({
    属性名称:属性类型(类型的首字母大写),
    ......（系统自动生成的`_id`不需要声明）
});
建立模型对象与数据库中数据集合的关联关系
let 变量名称=模块对象.model('名称',模型对象,'数据库目标集合名称');*/
```



### express配置

```js
//全局下载安装express
npm i express-generator -g
//创建express 项目名称
express test
//若创建失败管理员Windows PowerShell→set-ExecutionPolicy RemoteSigned→有a则a，无则y→重启vscode（R前为空）
/*文件解释
bin：存放服务器配置文件www（无特殊，不修改）
public：存放项目的公共资源（前端）
routes：存放路由配置文件。（后端）
views：存放模板文件
app.js：服务器入口文件（重要）
package.json：管理包的配置文件
*/

//流程--------------
express firstExpress
npm i
删除app.js中最后一行module.exports = app;
//app.listen(端口号,服务器启动成功时调用的函数);
//查看系统端口占用情况netstat -ano
app.listen(3000,function(){    
    console.log('服务器启动成功!端口号为3000');
});
node app.js
//关闭服务器可以选择关闭当前终端或者输入ctrl+c
//nodemon  修改自动重启服务器; 下载`nodemon`包
npm i nodemon -g
//利用nodemon启动服务器
nodemon app.js
//http://主机:端口号/资源路径  (无资源路径默认index)
//本机:可以使用  localhost  或  127.0.0.1 
//查看自己电脑的IP
ipconfig
```



### Restful-路径传参-描述

```js
//查询
/class/findAll        /class    GET  获取资源
//删除
/class/delById       /class    DELETE  删除资源
//添加
/class/add              /class    POST  添加资源
//修改
/class/updateById  /class    PUT  修改资源

//前端   url:/一级路由名称/参数值1/参数值2/.....
$.ajax({    
    url:'/class/2/Java100',    
    type:'put',    
    success:function(data){        
        console.log(data);    }
})
//后端  二级路由配置声明参数接收的属性名称
///:接收参数值1的属性名称/:接收参数值2的属性名称/.....
router.put('/:id/:name',function(req,res){
    
});
//在对应后端代码的回调函数中使用  req.params.接收参数值的属性名称
router.put('/:id/:name',function(req,res){    
    //根据编号修改班级名称，并将处理结果响应给浏览器    
    console.log('修改');    console.log(req.params.id,req.params.name);   
    res.send('修改成功');
});
```

### Restful-路径传参-方法描述-实例

```js
//查询方式一
/*async function(){
    let re=await mongoose.model('名称').find({});//通用
}*/
router.get('/',async function(req,res){
    //查询user集合的所有数据
    let re=await mongoose.model('userModel').find({});
    console.log(re);
});
//查询方式二
/*async function(){
    let re=await 变量名称.find({});//简易
}*/
router.get('/',async function(req,res){
    //查询user集合的所有数据
    let re=await userModel.find({});
    console.log(re);
});
//API---------
//查询所有  let re=await 名称.find({});
let re=await userModel.find({});
//指定属性值查询   let re=await 名称.find({    目标属性名称:值a});
//值a可为对象进一步描述：
//大于：{$gt:25  }，小于lt，大于等于gte，小于等于lte
let re=await studentModel.find({   gender:'男'    });
let re=await studentModel.find({    age:{        $lte:25    }});
//满足其一
let re=await 名称.find({    
        $or:[   { 条件1  },   {   条件2 },   ......  ]  
 });
let re=await studentModel.find({    
    $or:[   
 	   {  age:{  $lt:25  }  },       
    	{   gender:'女'   }    
     ]   });

//属性为in中任意一个值
let re=await 名称.find({    目标属性名称:{    $in:[值1,值2,......]}    })
let re=await studentModel.find({    age:{   $in:[22,25,28] }     });

//属性不为nin（no in）中任意一个值
let re=await 名称.find({    目标属性名称:{        $nin:[值1,值2,......]    }})
let re=await studentModel.find({    age:{        $nin:[22,25,28]    }});

//满足所有
let re=await 名称.find({    
    $and:[ {  条件1     },    {  条件2     },  ......    ]   });
let re=await studentModel.find({    
    $and:[  {   age:{   $gt:24   }  },  {   age:{   $lt:27    }  }    ]   
});

//满足正则
let re=await 名称.find({  目标属性名称:{   $regex:'正则表达式'    }});
let re=await studentModel.find({    name:{        $regex:'^张'    }});
```

### Restful-CRUD(增删改)描述+实例

```js
//新增
let re=mongoose.model('名称').create({    属性名称:属性值,    ......});
let re=await mongoose.model('courseModel').create({    
    name:'NodeJS',    
    credit:8,    
    period:15
});

//删除  re.deleteCount  为删除个数
let re=mongoose.model('名称').deleteMany({    条件})
let re=await mongoose.model('courseModel').deleteMany({    
    name:{        $regex:'^a'    }
});

//修改  re.modifiedCount为修改个数
let re=mongoose.model('名称').updateMany({    要修改的查找条件},{    新对象内容})
let re=await mongoose.model('courseModel').updateMany(
    {   name:'bootstrap框架'},
    {    credit:1}
);

//查询为find
```

### 多集合关联模型配置（查询）--描述+实例

```js
A→B型     1对1,模型配置----------
/*属性名称:{
    type:mongoose.SchemaTypes.ObjectId,
    ref:'关联的目标集合在程序中注册的名称'
}*/
let mongoose=require('mongoose');
let classSchema=new mongoose.Schema({
    name:String
});
mongoose.model('classModel',classSchema,'class');
let studentSchema=new mongoose.Schema({
    name:String,
    age:Number,
    gender:String,
    classId:{
        type:mongoose.SchemaTypes.ObjectId,
        ref:'classModel'
    }
});
mongoose.model('studentModel',studentSchema,'student');
A→B型     1对1,js查询配置----------
mongoose.model('名称').find({查询条件}).populate('属性名称')
let re=await mongoose.model('studentModel').find({}).populate('classId');

A→BBB型     1对1(数组)同集合的多个,模型配置----------
/*属性名称:[{
    type:mongoose.SchemaTypes.ObjectId,
    ref:'关联的目标集合在程序中注册的名称'
}]*/
//引入mongoose
let mongoose=require('mongoose');
let courseSchema=new mongoose.Schema({
    name:String,
    credit:Number,
    period:Number
});
mongoose.model('courseModel',courseSchema,'course');

let teacherSchema=new mongoose.Schema({
    name:String,
    tel:String,
    salary:Number,
    courseId:[{
        type:mongoose.SchemaTypes.ObjectId,
        ref:'courseModel'
    }]
});
mongoose.model('teacherModel',teacherSchema,'teacher');

A→BBB型     1对1(数组)同集合的多个,js查询配置----------
mongoose.model('名称').find({查询条件}).populate('属性名称')
let re=await mongoose.model('teacherModel').find({
}).populate('courseId');

A→B→C型     嵌套,模型配置----------
...........暂无............
A→B→C型     嵌套,js查询配置----------
/*mongoose.model('名称').find({查询条件}).populate({
    path:'属性名称',
    populate:{
        path:'属性名称'
    }
})*/
let re=await mongoose.model('scoreModel').find({
    score:{
        $lt:60
    }
}).populate({
    path:'studentId',
    populate:{
        path:'classId'
    }
});
```





### 后端传统路径-描述

```js
//描述
let express=require('express');
let router=express.Router();
router.请求方式('/二级路由',function(request,response){
    后端程序代码
});
//- GET请求传参，后端使用  request.query  获取
//- POST请求传参，后端使用  request.body  获取
module.exports=router;
/*解释
引入express模块
获取路由对象
*/
```

### 后端传统路径-实例

```js
//编写后端代码实现用户模块功能
let express=require('express');
let router=express.Router();
router.post('/login',function(request,response){
    console.log(request.body);
    console.log('执行login-post');
    response.send({
        message:'登录成功!'
    })
});
module.exports=router;
//引入express模块
//获取路由对象
//二级路由配置:为当前后端程序取个名字
//request获取请求相关数据
//response响应
```

### app.js注册声明--描述

```js
//后端主js引入    let 变量名称=require('./routes/JS文件名称');
let loginRouter=require('./routes/user');
//后端一级路由配置  app.use('/一级路由',变量名称);
app.use('/user',loginRouter);
//数据库链接
require('新建的JavaScript文件路径');
```

### 前端登陆/注册实例

```js
/*前端请求目标后端资源
- 请求资源路径:`/一级路由/二级路由`
- 请求方式(跟要执行的后端程序的请求方式对应)*/
<form action="/user/login" method="post">
    <label for="acc">账号:</label>
    <input type="text" id="acc" name="acc" placeholder="请输入11位手机号">
    <br/>
    <label for="pwd">密码:</label>
    <input type="text" id="pwd" name="pwd" placeholder="请输入6~12位数字或字母">
        <label for="gpwd">密码:</label>
      <input type="text" id="gpwd" name="gpwd" placeholder="再次输入密码">
    <br/>
    <input type="submit">
</form>
```

## 4-文件上传--实例

```js
前端-------------------
<input type="file" id="myPicture">
    //点击上传按钮时发送(上传)文件
$('#uploadBtn').on('click',function(){  }
//获取选中的文件对象  file.name为文件名，前后端获取不同
let file=document.querySelector('#myPicture').files[0];        
//检查上传文件的合法性
if(!file){
    //没有选择上传的文件
    alert('请选择要上传的文件!');
    return;
}
//确定上传的文件类型是否为目标类型
//图片的正则
let picRegex=/\.(png|jpg|jpeg|gif)$/;
if(!picRegex.test(file.name)){
    alert('头像只能是图片类型哦~');
    return;
}
//创建表单数据对象  通过ajax将文件数据以表单格式上传
let form=new FormData();
//将要上传的文件对象添加到表单数据中，并取一个名称
form.append('pic',file);
//通过ajax将数据发送到服务器
$.ajax({
    url:'/upload',
    type:'post',
    data:form,
    success:function(data){
        console.log(data);
    },
    //防止jQuery对传输到后端的数据进行自动格式处理
    contentType:false,
    processData:false,
    cache:false
});

后端--主js文件---------------
//下载`multer`插件(工具包)
npm i multer
//在要接收文件数据的后端模块路径引入`handleFile.js`
let {uploadFiles}=require('../util/handleFile');
//配置上传的文件信息
let uploadMethod=uploadFiles({
    path:'./public/images',//上传文件保存路径
    key:'pic',//上传文件在表单数据中的名称，要与前端取的名称对应
    size:1024//上传文件的大小限制，单位为KB
});
//获取上传的文件数据
uploadMethod(req,res,function(err){
    //有接收结果后要执行的回调函数(成功或失败)
    if(err){ //接收失败
res.send({code:250,message:'上传失败!'});
    }else{
        //获取上传的文件信息
        console.log(req.files[0]);
        res.send({   //接收成功
            code:200,message:'上传成功!',
            data:`http://127.0.0.1:3000/images/${req.files[0].filename}`
        });
    }
});
//req.files[0].filename文件名
```



## 5-后端跨域配置

app.js文件配置--实例

```js
// 设置 CORS 允许跨域
var allowCrossDomain = function (req, res, next) {
    // 设置允许哪一个源（域）可以进行跨域访问，* 表示所有源
    res.header("Access-Control-Allow-Origin", "*");
    // 设置允许跨域访问的请求头
    res.header("Access-Control-Allow-Headers", "X-Requested-With,Origin,Content-Type,Accept,Authorization");
    // 设置允许跨域访问的请求类型
    res.header("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE");
    // 设置允许 cookie 发送到服务器 
    res.header('Access-Control-Allow-Credentials', 'true');
    next();
};
//在一级路由配置前将响应头配置函数应用到系统中
app.use(allowCrossDomain);
```

## 6-token身份认证

前端

```js
//准备
//登录成功，将服务器响应的token进行存储到本地
$.ajax({
    url:`登录的URL`,
    type:'请求方式',
    success:function(data){
    ......
        //将用户token存储到本地
        sessionStorage.setItem('token',data.data);
    }
})

//鉴权：--登录成功后才能访问的资源，在请求头中携带token
sendAuthAjax('获取登录数据的后端程序URL','请求方式',function(data){
    console.log(data);
})
function sendAuthAjax(url,type,method) {
    $.ajax({
        url,
        type,
        headers: {
            Authorization: 'Bearer ' + sessionStorage.getItem('token')
        },
        // dataType:'jsonp',
        success: method,
        error: function () {
            alert('鉴权失败!请重新登录!');
            location.href = 'login.html';
        }
    });
}
/*
$.ajax({
    url:'要请求的资源路径',
    type:'请求方式',
    headers:{
        Authorization:'Bearer '+token值
    },
    success:function(data){
        console.log(data);
    },
    error:function(){
        alert('鉴权失败!请重新登录!');
        location.href='login.html';
    }
})*/
```

后端

```js
//准备
//下载第三方插件，用于生成token
npm i jsonwebtoken
//引入`jsonwebtoken`插件
let jsonwebtoken=require('jsonwebtoken');
//生成token
let token=jsonwebtoken.sign({
    user:用户数据对象
},'秘钥',{
    expiresIn:时间   //number型:表示指定秒后token失效，string型:带单位，指定时间后token失效，比如'1h'，表示1小时候token失效
});

//鉴权----------
//下载第三方插件实现鉴权功能
npm i express-jwt
//鉴权配置，并应用到系统中-----------
//auth.config.js配置内容:----------
//引入鉴权插件
let {expressjwt}=require('express-jwt');
let jwtAuth=expressjwt({
    secret:'xumin',//秘钥,与生成token的秘钥保持一致
    algorithms:['HS256'],//jwt算法
    credentialsRequired:false//false:不带token的请求不进行鉴权验证;true:请求无论是否携带token，都要鉴权，如果不带token直接鉴权失败
}).unless({
    path:['/user/login','/user/register']
});
//暴露鉴权配置对象
module.exports=jwtAuth;

//应用到系统中，在`app.js`中配置---------
//引入配置文件  //应用到系统中----------
let jwtAuth=require('auth.config文件路径');
app.use(jwtAuth);

//后端解密----------------
//引入`jsonwebtoken`插件   //引入jwt插件
let jsonwebtoken=require('jsonwebtoken');
//获取请求头中的token数据
let token=请求对象.get('Authorization').split(' ')[1];
//根据token解密获取用户数据 后一个user对应登陆时村的名字
let user=jsonwebtoken.verify(token,'秘钥').user;
```

